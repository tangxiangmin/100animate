<!DOCTYPE html>
<!--
	作者：tangxiangmin@126.com
	时间：2016-08-28
	描述：由于之间的逻辑处理存在问题，因此重新书写整个逻辑
-->
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<link rel="stylesheet" href="../css/style.css"/>
		<style rel="stylesheet">
			.wrap { position: relative;}
			
			.red { background: #CC0033;}
			.blue { background: #00CCFF;}
			.black { background: #000033;}
			.green { background: #00CC66;}
			
			.box { position: absolute; left: 0; top: 0; height: 300px; width: 300px;;}
			.node { 
				width: 30px; height: 30px; position: absolute;
				box-sizing: border-box;
				padding: 2px;
			}
			.node .inner {
				width: 26px;
				height: 26px;
				margin: 2px;
				/*调试样式*/
				color: yellow;
				text-align: center;
				line-height: 26px;
			}
			.score {
				position: absolute;
				right: 0;
				top: 0;
				
			}
		</style>
	</head>
	<body>
		<h1>简易版宝石迷阵</h1>
		<p>
			<a href="../index.html">返回主菜单</a>
		</p>
		<div class="wrap">
			<div class="score">0</div>
			<div class="box">
				
			</div>
		</div>
		<!--华丽丽的分割线-->
		<script src="../js/jquery-1.12.4.min.js"></script>
		<script>
		$(function(){
			var row = 5;
			var col = 5;
			var w = 30;
			var h = 30;

			//初始化节点地图
			(function(){
				var str = "";
				for (var i = 0 ; i < row; ++i){
					for (var j = 0; j < col; ++j){
						str += "<div class='node'><div class='inner'></div></div>";
					}
				}
				
				$(".box").append($(str));
				var color = ["red","blue","black","green"];
				
				$(".node").each(function(index){
					$(this).css({"left":(index%col)*w,"top":parseInt(index/row)*h})
						   .find(".inner").addClass(color[Math.floor(Math.random()*4)]);
				})
				
			})();
			
			
			(function(){
				//将颜色映射到一个二维数组，该二维数组与节点的定位有关，与节点的顺序无关
				var colorMap = [];
				for (var i = 0; i < row; ++i){
					colorMap.push([]);
				}
				$(".node").each(function(){
					var l = parseInt($(this).css("left"));
					var t = parseInt($(this).css("top"));
					var color = $(this).find(".inner").attr("class").split(" ")[1]
					colorMap[t/h][l/w] = color;
				})
				//根据坐标获取节点
				function getNode(row,col){
					for (var i = 0; i < $(".node").size(); ++i){
						if ($(".node").eq(i).css("top") == (row*h +"px")&& $(".node").eq(i).css("left") == (col*w+"px")){
							return $(".node").eq(i);
						}
					}
				}
				//竖直方向上相同的元素
				for (var i = 0; i < col; ++i){
					var result = checkVerticalSame(i);
					if (result) {
						for (var j = 0; j < result.length; ++j){
							getNode(result[j],i).find(".inner").text("O");
						}
					}
				}
				//水平方向上相同的元素
				for (var i = 0; i < row; ++i){
					var result = checkHorizonSame(i);
					if (result) {
						for (var j = 0; j < result.length; ++j){
							getNode(i,result[j]).find(".inner").text("O");
						}
					}
				}
				
				function checkVerticalSame(col){
					var temp = [];
					for (var i = 0; i < row; ++i){
						temp.push({
							color:colorMap[i][col],
							index:i
						});
					}
					return pickSameColor(temp);
				}
				
				function checkHorizonSame(row){
					var temp = [];
					for (var i = 0; i < col; ++i){
						temp.push({
							color:colorMap[row][i],
							index:i
						});
					}
					return pickSameColor(temp);
					
				}
				//待优化
				function pickSameColor(temp){
					var same = [];
					var box = [temp[0]];
					for (var i = 0; i < temp.length-1; ++i){
						if (temp[i].color == temp[i+1].color){
							box.push(temp[i+1]);
						}else {
							same.push(box);
							box = [temp[i+1]];
						}
					}
					same.push(box);
					
					//将三个或以上相同元素的索引值存入数组并返回，索引值在同一行或列，不会重复，因此只需要一个一维数组
					var arr = [];
					for (var i = 0; i < same.length; ++i){
						if (same[i].length >=3){
							for (var j = 0; j < same[i].length; ++j){
								arr.push(same[i][j].index);
							}
						}
					}
					if (arr.length >=3){
						return arr;
					}
					
				}
			})();
			
		})
			
		</script>
	</body>
</html>
